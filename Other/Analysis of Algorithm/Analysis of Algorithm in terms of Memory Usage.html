<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>Analysis of Algorithm</title>

    <!-- Bootstrap core CSS -->
    <link href="../Resources/bootstrap.min.css" rel="stylesheet">

  </head>

  <body>

    <div class="container">

      <!-- Static navbar -->
      <nav class="navbar navbar-default">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" style="font-size:20px;">Analysis of Algorithm in terms of Memory Usage</a>
          </div>
          <div id="navbar" class="navbar-collapse collapse">
    
          </div><!--/.nav-collapse -->
        </div><!--/.container-fluid -->
      </nav>

      <!-- Main component for a primary marketing message or call to action -->
      <div class="jumbotron">
        <h1>Task 1</h1>
        <p>
        <b>Space Complexity : Big-O(m)</b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         where m is the number of characters in the input infix expression
		<br> <br>
		The input infix expression is traversed in one loop ( m iterations ). There are pop() and push() operations being performed on the stack depending on the array 	elements. Essentially we just have two stacks that store the input shared between them.
		<br> <br>
        Maximum number of elements to be stored at one time : m
Hence the overall time complexity turns out to be Big-O(m).
        </p>
      </div>
      
      <div class="jumbotron">
        <h1>Task 2</h1>
        <p>
        <b>Space Usage on Stack Frame : Big-O(h)</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  where h is the height of the binary tree which is finally generated <br><br>
		<b>Space Usage for Tree : Big-O(n)</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  where n is the number of characters in the generated prefix expression
                  <br><br>
		The algorithm traverses through the generated prefix expression array prefix[]. At each element of the array following operations are performed:<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i)   creating a new node<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii)  checking if the element is an operator<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.a) checking if it is the last element<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.a.1) checking if the operator is '~'<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.b) recursive calls to create left and right subtree<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii) incrementing the pointer used to traverse through the array<br><br>
	We can have h stack frames. With each stack frame having O(1) space, total space complexity is Big-O(h).
        </p>
      </div>
      
       <div class="jumbotron">
        <h1>Task 3</h1>
        <p>
        <b>Space Complexity : Big-O(h)</b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            where h is the height of the binary tree<br><br>
  		The algorithm consists a method which traverses the binary parse tree in the fashion of inorder traversal. Space complexity of this recursive functions is:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(number of stack frames)*(space per stack frame)<br><br>
 	 	In this case, in worst case, we can have h stack frames. With each stack frame having O(1) space, total space complexity is Big-O(h).
        </p>
      </div>
            
      <div class="jumbotron">
        <h1>Task 4</h1>
        <p>
        <b>Space Complexity : Big-O(h)</b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            where h is the height of the binary tree<br><br>
		The algorithm consists a method which traverses the binary parse tree. At each node, there is a recursive call to the left and the right sub-trees. With each call, 		more and more stack frames are being occupied.<br><br>
 		Space complexity of this recursive functions is :<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  (number of stack frames)*(space per stack frame)<br><br>
		In this case, we can have h stack frames. With each stack frame having O(1) space, total space complexity is Big-O(h).

        </p>
      </div>
      
      <div class="jumbotron">
        <h1>Task 5</h1>
        <p>
        <b>Space Complexity : Big-O(h)</b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           where h is the height of the binary tree<br><br>
		The algorithm consists a method which traverses the binary parse tree. At each node, there is a recursive call to compute the values from left and right sub-trees. 		Recursive calls reside on stack.<br><br>
 		Space complexity of this recursive functions is :<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(number of stack frames)*(space per stack frame)<br><br>
		In this case, we can have h stack frames. With each stack frame having O(1) space, total space complexity is Big-O(h).

        </p>
      </div>
		

    </div> <!-- /container -->


  </body>
</html>
